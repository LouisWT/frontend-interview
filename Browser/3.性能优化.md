# 优化方式有哪些
- 优化图片文件：针对图片文件类型
- 压缩CSS和JS代码
- 使用按需加载
- 使用缓存：强缓存、协商缓存
- 针对网络请求优化：DNS预解析、预加载、预渲染、使用 HTTP 2.0
- 使用 CDN（内容分发网络）实现就近请求

# 文件优化
1.	服务器端开启 Gzip 
2.	对于图片文件
    - 小图可以使用 base64 内联进代码，减少请求
    - 网站的图标整合为一张雪碧图，使用 PNG-8格式
    - 照片可以使用 JPG 格式（有损压缩，色彩丰富）
    - 对色彩要求极高，可以用PNG-24格式（无损压缩，色彩丰富）
    - 对能显示 webP 格式浏览器，尽量使用 webP
3.	对于CSS文件
    - 将引入样式文件的link 标签放入head 中。
	`<link rel="stylesheet" type="text/css" href="main.css" />`
    - 原理：浏览器为了避免样式变化重新绘制页面元素，会等待所有样式加载完毕之后才渲染页面。如果CSS文件放置在底部，会阻止页面内容一步一步地呈现，从获取到 html直到在CSS文件下载解析地过程中，会一直出现白屏。
4.	对于JS文件
    - 将script 标签放在 body 的底部。因为JS文件的执行会阻塞渲染
    - 可以加上 defer 属性，JS 会异步下载，并且在HTML解析完之后顺序执行
    - 对于没有依赖的文件，可以使用 async 属性，异步下载脚本

# 网络相关优化
- DNS 预解析: `<link rel=”dns-prefetch” href=”//louiset.top”>`，节省DNS解析的时间
- 预加载: `<link rel=”preload” href=”http://example.com”>` 预先加载之后会用到的资源
- 预渲染: `<link rel=”prerender” href=”http://example.com”>`预先渲染接下来用到的页面
- 使用 HTTP2.0。HTTP2.0 采用了多路复用技术，可以多个请求复用一个TCP连接，并且支持Header压缩，性能提升很大。(浏览器有并发请求限制，每个请求都需要断开连接，并且TCP有慢启动的问题，加载大文件比较慢)

# 按需加载
只加载可视区域内需要加载的东西。比如有一个图片列表，那么可以先只加载前10张图片，撑满可视区域多一点，之后在滚动后，如果快到达列表底部，再加载5张图片。只加载需要加载的资源

# 缓存
缓存策略：服务器端将 Cache-Control 设置为一个非常大的值，然后使用 webpack 编译的时候，给每个文件利用文件内容生成一个 hash值作为文件名，这样如果文件内容改变，缓存就失效了，可以及时访问到新文件，如果文件内容没有改变，那么强缓存就一直有效。

缓存类型包括强缓存和协商缓存。强缓存不需要请求，协商缓存需要请求:

1. 可以通过 Expires 和 Cache-Control 头部来实现强缓存。表示在过期之前，不需要请求就可以直接使用资源。
```
Expires 设置绝对过期时间，Cache-Control 设置的是相对的过期时间，单位为秒。Cache-Control 的优先级更高

Expires: Wed, 22 Oct 2018 08:41:00 GMT
Cache-Control: max-age=30
```
2.	强缓存失效之后，就需要协商缓存了。协商缓存需要发送请求，如果缓存有效会返回 304。
```
If-Modified-Since 字段。它会将 Last-Modified 的值(文件最后的修改时间)发给服务器，询问在这个时间后，文件是否更新过，有更新将文件发回来

If-None-Match 字段，它会将 Etag（类似于文件指纹）发送给服务器，询问Etag是否改变，如果改变了把文件发回来。

Etag 优先级大于 Last-Modified
```
相关头部：
服务器端：Cache-Control、 Expires、 Last-Modified、 Etag
客户端：If-Modified-Since、 If-None-Match

Cache-Control 头部的值:
- no-store 不缓存
- no-cache 使用前需要进行协商
- max-age=30 30秒过期前直接用，过期后要协商

# CDN
使用 CDN 的内容分发网络来就近加载。

原理：在用户和服务器之间增加一个 cache 层，将用户的请求引导到就近的CDN缓存服务器，由CDN缓存服务器向源服务器发起请求，CDN缓存服务器除了会将响应返回给客户端，也会响应缓存在本地以备以后使用。

实现原理：将对源服务器的DNS解析转为对CDN缓存服务器的DNS解析，这是通过DNS解析记录的 CNAME 实现的。为了得到实际IP地址，浏览器需要再次对获得的CNAME域名进行解析以得到实际的IP地址；在此过程中，使用的全局负载均衡DNS解析，如根据地理位置信息解析对应的IP地址，使得用户能就近访问。（CDN服务来提供最近的机器）

# 从输入 URL 到显示网页发生了什么
1.	对域名进行DNS解析，获取IP地址
2.	然后TCP会先进行三次握手。具体传输过程是
    - TCP会指明双方的端口号，然后给网络层
    - 网络层会指明双方的IP地址，然后给数据链路层。
    - 数据链路层会指明下一跳的MAC地址，然后就是物理层比特流传输了
3.	TCP握手之后，如果使用了 HTTPS会进行TLS握手
4.	正式传输数据。
5.	服务器收到请求之后，处理请求，假设返回了一个HTML文件
6.	浏览器收到响应后，会先判断响应状态码，如果是 200，那就正常解析，400或者500会报错，300会进行重定向
7.	然后浏览器解析文件，如果是 gzip 会先解压，然后通过文件编码格式来解码
8.	文件解码成功后，开始渲染流程
    - 解析HTML生成DOM树。（从上到下解析过程中遇到了加载图片 CSS 就异步加载，JS 如果不加 defer async 都是同步加载执行的）
    - 解析CSS生成CSS规则树
    - 合并DOM树和CSS规则树生成渲染树
    - 根据渲染树来计算布局，也就是元素的尺寸位置
    - 交给GPU绘制，合并图层，在屏幕上显示

